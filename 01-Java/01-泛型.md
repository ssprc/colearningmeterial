# 泛型

> 1. 为什么要使用泛型？
> 2. 泛型类、泛型接口泛型方法
> 3. 泛型在继承与实现中的表现
> 4. 泛型的擦除
> 5. 泛型的通配（逆变与协变）



**为什么要使用泛型？**

> 1. **类型安全性：** 泛型使得编译器能够在编译时检查类型，从而捕获许多在运行时可能导致异常的类型错误。这有助于减少代码中的潜在错误。
>
> 2. **代码重用：** 泛型允许您编写通用代码，可用于处理多种数据类型，而无需为每种类型编写单独的代码。这提高了代码的重用性。
>
> 3. **代码可读性：** 泛型使代码更具可读性，因为它们允许您在代码中使用更具描述性的类型参数名称，而不仅仅是`Object`。这使得代码更易于理解和维护。
>
> 4. **性能优化：** 泛型允许编译器执行更严格的类型检查，这可以帮助优化生成的字节码，以提高性能。例如，在没有类型擦除的情况下，编译器可以生成更精确的类型检查代码。
>
> 5. **减少强制类型转换：** 泛型减少了需要手动进行强制类型转换的情况，因为编译器可以自动插入类型转换代码。
>
> 6. **更好的工具支持：** 泛型允许集成开发环境（IDE）和其他开发工具提供更好的代码分析和建议，以帮助开发人员编写更健壮的代码。
>



### 泛型的擦除

在Java中，泛型是需要被删除的，在编译的时候，泛型参数会被替换成它的原始类型，T会变成Object。

因此，在实际运行的时候，没有办法获得关于T的信息。不过在 Java 和 Kotlin 中，编译器会根据泛型的类型参数信息生成相应的字节码和辅助信息。这些信息用于在编译后的程序中进行类型检查和类型转换。

例如：

```java
public class MyGenericClass<T> {
    private T value;

    public MyGenericClass(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```

在编译的时候，编译器会把这个代码中的T替换为Object实现擦除

```java
public class MyGenericClass {
    private Object value;

    public MyGenericClass(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return this.value;
    }

    public void setValue(Object value) {
        this.value = value;
    }
}

```

对于你使用泛型类的代码：

```java
MyGenericClass<Integer> myGeneric = new MyGenericClass<>(42);
Integer intValue = myGeneric.getValue(); // 不需要额外的强制类型转换
```

这里不需要你再进行强制转换，虽然实际是强制从Object转换过来的，只是这个工作是Java虚拟机自动进行的，它会保留你`myGeneric` 的泛型信息，可以放心地将其从Object转换成Integer



这个过程就是解决了**类型安全**的问题



为什么要进行类型擦除呢？

1. 减少运行时的开销，如果不擦除，就会保留很多泛型信息，有的很多是没有必要的。

   > 我的理解：
   >
   > 在使用List<T> 的时候，如果我创建了一个List<Car>的对象，不擦除的话，会保留一份所有的List接口提供的方法。 然而我可能只用了一个add方法。

2. 可重用性：擦除允许你编写通用的泛型代码，而不必为每个不同的类型生成新的字节码。这使得编写更具可重用性的泛型库和框架变得更加容易。



总的来说，擦除是在编译器和虚拟机中的平衡的产物，

我们需要使用泛型来实现代码的重用，不想为不同的参数创建新的字节码，如果在编译的时候使用Object，会带来很多**类型安全的问题**，我们希望在编译的时候就发现这些问题，而不是真正运行的时候才发生类型转化错误（` ClassCastException`）。因此使用泛型是一个很好的选择。

但是，如果在编译的时候不进行泛型的擦除，会为很多不必要的对象保留很多字节码文件（List<Car> 的例子），因此擦除是一个很好的选择。



就是为了方便且安全，使用泛型

为了减少开销和编译运行时效率，进行擦除





如果一个方法，需要在类型转换的时候获取类型的信息（在函数内部获取，强制转换不能用）的时候，该怎么办？













